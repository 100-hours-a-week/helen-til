# 🧾TIL
## 날짜: 2025-02-04

- 학습 목표 1 : 
- 학습 목표 2 : 
- 학습 목표 3 : 

### 새로 배운 내용

### 학습 키워드 한 줄 정리
|  | 정의 | 비고 |
| --- | --- | --- |
| 프로세스 | 연속적으로 실행되고 있는 컴퓨터 프로그램  | - 메모리를 할당 받아 독립적으로 실행된다
프로세스 간 통신 : IPC / 복잡하다
- 크롬 브라우저의 여러 탭들은 프로세스이다. 스레드들로 이루어지면, 다른 스레드가 터지면 자원을 공유하는 다른 스레드에도 영향이 갈 수 있기 때문 |
| 스레드 | 하나의 프로세스 안에서 실행되는 흐름 | - 같은 프로세스 내 스레드들은 메모리를 공유하여, 데이터 공유 및 통신이 용이하다
- 컨텍스트  스위칭이 프로세스에 비해 오버헤드가 덜 하다
- 멀티태스킹 |
| 동시성 | 여러 작업이 번갈아서 실행되는 것 | - 동시에 실행하는 것이 아니라 “동시”처럼 보이도록 하는 것
- 동시성 문제는 프로세스/스레드가 공유 자원에 접근할 때 발생할 수 있는 문제 |
| 병렬성 | 여러 작업이 실제로 동시에 수행되는 것 |  |
| 컨텍스트 스위칭 | CPU가 수행중이던 프로세스/스레드의 작업을 멈추고 다른 프로세스/스레드를 실행하는 것 |  |
| critical section | 공유 자원에 접근하는  코드 영역 | - 하나의 프로세스/스레드가 접근할 수 있도록 관리해야 한다 |

### 주제 1: 프로세스와 스레드
#### 프로세스, 스레드 개념이 중요한 이유

제대로 이해하지 못하고 코딩 시 발생하는 문제

> 메모리 공간의 독립성 관련 문제 상황 발생
> 
- MSE에서는 동일한 데이터를 다룰 때 각 서비스가 독립된 메모리 공간을 가지므로, 복잡한 동기화 및 통신 로직이 필요
- 일관성 없는 데이터로 인해 잘못된 정보가 표기되면 신뢰성이 하락할 수 있다.

#### 동시성 문제

: 여러 프로세스/스레드가 공유 자원에 접근할 때 발생할 수  있는 문제들 (데이터의 일관성이 지켜지지 않는 문제 발생 가능) 

> 동시성과 병렬성
> 
- `동시성` : 여러 작업이 번갈아서 수행되는 것
- `병렬성` : 여러 작업이 실제로 동시에 수행되는 것

> 동시성 관리
> 
- 여러 계산 과정이나 작업들이 시스템에서 동시에 실행되도록 조정하는 기술 및 과정

#### 프로세스와 스레드 사용 시 고려할 사항

각자 트레이드 오프가 있으므로 기술적 고려가 필요하다.

> 프로세스
> 
- 프로세스 간 통신 과정 복잡 ⇒ IPC
- 컨텍스트  스위칭 시 스레드에 비해 오버헤드가 큼
- 자원 사용 비효율적
    - 각 프로세스는 독립적인 메모리 공간을 갖는다.

> 스레드
> 
- 자원 사용 효율적
    - 스레드 간 메모리 공간 공유하므로 자원 사용 효율적
- 자원 사용 복잡성
    - 같은 프로세스 내 스레드 간의 동기화 로직 필요. 스레드가 많아질수록 복잡해짐
- 하나의 스레드에서 발생한 문제가 다른 스레드에 영향을 줄 수 있음
- 빠른 처리 속도: 컨텍스트 스위칭 시 오버헤드가 프로세스보다는 적음

#### 컨텍스트 스위칭

: 문맥 교환

작업을 하던 특정 프로세스/스레드의 태스크를 멈추고 다른 프로세스/스레드의 태스크를 수행하는 것을 의미한다.

#### 프로세스 메모리 영역

- **`Code`**
- **`Data`**: 정적 변수, 전역 변수 등 저장. 프로그램 실행 시 할당되고, 종료 시 소멸
- **`Stack`**: 함수 호출 관련 매개 변수, 지역 변수, 반환 값 등이 저장되는 영역. 함수가 종료되면 스택에서 제거된다.
- **`Heap`**: 동적으로 할당되는 데이터를 위한 공간, new 객체로 생성되는 것들

#### 프로세스 동작

1. 로딩
    - 프로그램이 메모리에 로드 되는 과정
2. 실행
    - 메모리에 로드된 프로그램을 명령어 단위로 cpu가 수행하는 과정
3. 대기
    - 네트워크  동작, I/O 등의 이벤트 발생 시 완료 시까지 기다리는 과정
4. 종료

### 주제 2: 아키텍처 패턴과 학습 

### 오늘의 도전 과제와 해결 방법
- Java 스레드 동시성 관리 실습

1. **공유 자원 클래스** 만들기
- Counter라는 클래스를 만들어 int value를 갖도록 한다.
- increment() 메서드를 만들어, value를 1씩 증가시키도록 작성한다.
1. **스레드 클래스** 만들기
- 예: IncrementThread라는 클래스를 만들고,
- Thread를 상속받거나 Runnable을 구현하도록 한다.
- 생성자에서 Counter 객체를 받아와서 저장한다.
- run() 메서드 안에서는 일정 횟수(예: 1000번)만큼 increment()를 호출한다.
1. **메인 메서드**에서 테스트
- Counter 인스턴스를 하나만 생성한다.
- IncrementThread 스레드를 2개 이상 만들어서 동시에 실행(start)시킨다.
- 모든 스레드가 끝난 후(필요하면 join() 활용) Counter의 value를 출력한다.
- 예측한 값(예: 2개의 스레드가 각각 1000번씩 더하면 2000)과 실제 결과를 비교한다.
1. **동시성 문제 확인**
- 처음엔 increment() 메서드에 어떤 동기화 처리를 하지 않고 돌려본다.
- 실제로 여러 번 실행해보면, 때로는 2000이 안 되는 값을 찍을 수도 있다.
- 동시성 문제(원자성 깨짐)를 직접 체험해본다.
1. **동기화 적용 후 재실험**
- increment() 메서드에 `synchronized` 키워드를 붙이거나,
- AtomicInteger를 사용해서 수정해본다.
- 다시 실행해보고, 이제는 항상 2000(또는 예상값)이 정상적으로 나오는지 확인한다.

```java
public class App {

    public static void main(String[] args) throws Exception {

        Counter counter = new Counter(0);

        IncrementThread thread1 = new IncrementThread(counter);
        IncrementThread thread2 = new IncrementThread(counter);

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        System.out.println("current value = "+ counter.getValue());

    }

    static class Counter {
        private int cnt;

        public Counter(int cnt){
            this.cnt = cnt;
        }

        public synchronized void increment() {
            // "synchronized" 키워드로 여러 스레드에서 작업되지 않도록 예방 
            this.cnt += 1;
        }

        public int getValue() {
            return cnt;
        }
    }

    static class IncrementThread extends Thread {

        private Counter count;

        public IncrementThread(Counter count) {
            this.count = count;
        }

        public void run() {
            for (int i=0; i<100; i++) {
                count.increment();
            }
           
        }
    }
}
```

- 값을 1씩 증가시키는 Counter 클래스와 Thread 클래스를 상속한 IncrementThread  클래스를 만들어 주었다.
- Counter 객체는 하나를 생성했고, 스레드는 두 개를 생성해 start로 처음 실행 후 작업하여 최종 값을 출력하려 했으나, 1이 출력되었다.
    
    ⇒  thread1, thread2 각각이 끝나지 않은 채로 바로 출력을 시도했기 때문이다. 따라서, 각각의 스레드가 종료되기까지 기다리는 메소드인 `join`을 사용했다.
    
- 스레드 각각이 0으로 시작해 100까지 더해야 하므로 최종 200이 되어야 하지만, 출력 값은 160이 되었다. (동시성 문제 발생)
    
    ⇒  Counter 클래스의 increment() 메소드에 `synchronized` 키워드를 추가했다.
    
    여기서 나는  thread1이 100번 더할 때까지 기다린 후 thread2가 이어서 작업하는 것인 줄 알았는데, thread1이 실행하는 increment() 함수가 종료되면 다음 thread2가 사용할 수 있게 되는 lock & unlock 개념이었다. 따라서 thread1→thread2→thread1→… 이렇게 동시성 관리를 한다.
    
    정상적으로 200이 출력되었다.


### 오늘의 회고
오늘은  프로세스와 스레드의 개념에 대해서 학습했습니다.
특히 오늘 진행한 실습 과제에서 java에서의 스레드를 사용해보았는데, 어렵지만 재밌고 정말 중요한 개념이라고 생각합니다. 
프로세스는 메모리 공간을 별도로 가지고 있으며 독립적인 실행이 가능하지만, 메모리 자원 사용이 비효율적일 수 있습니다.
스레드끼리는 하나의 프로세스 내의 메모리 공간(code, data, heap)을 공유해 빠르고 효율적인 통신이 가능하고
프로세스에 비해 컨텍스트 스위칭 오버헤드가 적다는 특징이 있습니다.
또한 프로세스와 스레드의 개념과 더불어 동시성 관리가 중요한 이유도 학습하였습니다. 
그동안 동시성이 실제로 동시에 이루어지는 것이라고 생각했는데, '동시성'과 '병렬성' 개념을 다시 학습하며
잘못 알고 있었음을 깨달았습니다..🥹
동시성은 여러 작업을 번갈아가며 실행하는 것이고, 병렬성이 실제로 동시에 실행하는 것이었습니다.
동시성 관리는 공유 자원을 일관성 있게 유지하는 것이며, 멀티 프로세스/스레드 사용 시 중요한 개념 임을 배웠습니다.
점점 어려운 용어와 개념이 많아지고 있는데, 키워드를 잘 정리해야 할 필요성을 느꼈습니다.

### 참고 자료 및 링크
