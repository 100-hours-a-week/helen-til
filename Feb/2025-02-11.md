# 🧾TIL
## 날짜: 

## 새로 배운 내용

### 공유 자원

공유 자원이란 여러 프로세스, 스레드가 함께 공유하며 사용하는 시스템 내의 자원이다.

공유자원은 하드웨어 자원을 공유하여 비용을 줄이고 효율적으로 사용하기 위해 필요하다.

실생활에서의 예시는 **공유 프린터**가 있다. 회사 내 프린터가 한 대 밖에 없다고 할 때, 각 컴퓨터들이 동시에 출력을 요청할 경우, 대기 큐를 사용해 한 번에 하나의 문서만 출력할 수 있도록 조정한다.

개발 경험에서의 예시는 **DB 커넥션 풀**이 있다.  웹 어플리케이션에서 DB와 통신할 때 매번 새로운 연결을 생성하면 성능이 저하될 수 있다.  따라서 만들어둔 연결을 계속 재사용한다. (연결하고, 사용 후 반납, 연결…)

### 스핀락과 뮤텍스
|  | 스핀락 (Spinlock) | 뮤텍스 (Mutex) |
| --- | --- | --- |
| 대기 방식 | CPU를 계속 사용하며 반복 확인 | 스레드를 잠시 중지하고 대기 |
| 락 해제 시 | 즉시 락을 얻음 | 스케쥴러가 스레드를 깨운 후 락을 얻음 |
| 컨텍스트 스위칭 | 없음 (CPU 점유) | 있음 (스레드 스케줄링) |
| 짧은 락일 때 | 더 효율적 | 불필요한 컨텍스트 스위칭 발생 |
| 긴 락일 때 | CPU 낭비 | 더 효율적 |

### 뮤텍스와 세마포어

뮤텍스는 공유 자원에 동시 접근 하는 것을 막는 동기화 기법이며 프로세스, 스레드가 소유권을 가져  본인이 아니면 락을 해제할 수 없다.

세마포어는  접근 허용량 내에서 공유 자원에 동시 접근하는 것을 허용하는 동기화 기법이다. 특히, 이진 세마포어는 0과 1로 동작해 뮤텍스와 유사하지만 소유권 개념은 없다. 네트워크 접속 제한이나 스레드 풀 관리에 사용된다.

- 세마포어의 종류
    
    
    | **구분** | **이진 세마포어(Binary Semaphore)** | **카운팅 세마포어(Counting Semaphore)** |
    | --- | --- | --- |
    | **정의** | 값이 **0 또는 1**로 동작하며, **단일 자원**에 대한 접근을 제어. | 값이 **0 이상의 정수**로 동작하며, **다중 자원**에 대한 접근을 제어. |
    | **값의 범위** | 0과 1 | 0 이상 정수 |
    | **특징** | - 뮤텍스와 유사하지만 **소유권 개념이 없음.** | - 사용 가능한 자원의 수를 카운트하여 관리. |


### 데드락
둘 이상의 프로세스/스레드가 각자 다른 공유 자원을 점유한 상태에서, 서로의 공유 자원을 요청하며 무한하게 대기하는 상황

- 발생 조건
    - **상호 배제**: 임계 영역에 하나의 프로세스/스레드만 접근 가능
    - **점유 대기**: 점유한 상태에서 다른 자원을 대기함
    - **비선점**: 다른 프로세스나 스레드에 할당된 자원을 뺏어올 수 없음
    - **순환 대기**: 순환 형태로 자원을 대기함. A가 B가 가진 자원을 대기함 → B가 C가 가진 자원을 대기함 → C가 A가 가진 자원을 대기함 ..

### **카카오 크램폴린IDE 특강에서 배운 내용들**
#### 배포 방식 비교

> 로컬 기반의 배포
> 

Spring Boot의 버전 3.xx 일 때 자바 17버전 이상, 우분투 20이상

버전이 바뀐다면 연쇄적으로 바꾸어야 하므로 사이드 이펙트가  크다

> VM 기반의 배포
> 

Hypervisor 위에 서비스 당 guest os가 띄워져 있음

하나의 서비스에 하나의 VM ⇒ VM이 무거움, 확장 어려움

> 컨테이너 기반의 배포
> 

Host os위의 팟들 내부의 컨테이너 기반으로 배포

- 각각의 서비스를 격리된 환경에서 배포
- VM에 비해 더 가볍게 가상화
- 유연하게 확장 가능

#### 쿠버네티스 개요

: 컨테이너 오케스트라 툴, IaC (Infrastructure as Code)


- **`Auto Scaling`** :  9개의 서버에서 → 4개의 서버 (Auto Scaling)
- 서비스에서 몰리는 트래픽을 처리
- **`Auto Healing` :** 에러 발생 시 자동으로 팟을 띄워서 처리


- Cluster 안의 Node들
- Node 안의 namespace들. (독립적)
    - default namespace
    - dev namespace
    - qa namespace

#### 쿠버네티스 기본 개념

PODS : 쿠버네티스의 가장 작은 컴퓨팅 단위

- **`ReplicaSet`** : 다수의 pod 관리. 특정 갯수의 pod 만큼 관리. 장애가 발생하면 장애가 발생한 갯수만큼 pod를 띄움.
- **`Deployment`** :  파드를 새로운 버전으로 업데이트, 다양한 배포 방식 지원
    - 패키지가 아니라 이미지의 버전을 관리하는 것
- **`Service`** : Pod 그룹에 트래픽을 분산해서 전달


- **`Ingress`**가 외부의 트래픽을 적절한 서비스 객체에 트래픽 전달, nginx가 붙어있는 형태
- **`Service`**는 **`Pod`**들에 트래픽 분산
- **`Deployment`**는 팟들의 버전 업데이트 및 배포 관리
    - Recreate: 예전 버전의 팟들을 다 지우고 새로운 팟을 띄움. 시간이 걸림 ⇒ 다운 타임 (위험)
    - RollingUpdate

---

#### 크램폴린 IDE

- 사용 플로우 개요
    1. 크램폴린 IDE 이용한 개발
    2. Dockerfile 작성
        - 도커 이미지 == 어플리케이션 실행 패키지
        - **`Dockerfile`**: 이미지 빌드를 위한 설정 파일
    3. D2Hub 레포지토리에 이미지 빌드 및 업로드
    4. 쿠버네티스 yaml 작성
        - k8s/~.yaml
    5. Kargo 통해 DKOS 클러스터에 이미지 배포
        
        **`DKOS`**: 카카오에서 제공하는 쿠버네티스 자원
        
        **`KARGO`**: 지속적인 배포 기능 제공


### 오늘의 회고
오늘은 카카오 크램폴린 특강을 듣고, 팀 활동에서 다른 조원들이 정리한 내용을 읽어보고, 다시 정리하는 시간을 가졌다.

먼저 카카오 크램폴린 특강을 들으며, IDE에서 깃허브 레포 연동으로 이미지 빌드와 쿠버네티스 배포가 버튼 하나로 손쉽게 된다는 점이 센세이션했다. 🫥

그런데 쿠버네티스 배포가 아직은 어렵게 느껴지긴 해서, 시간이 된다면 추가적으로 제공된 IDE 사용 강의를 수강해볼 예정이다..🥹

그리고 이어서 오후에는 조별 정리 시간을 가졌다.

가장 기억에 남는 내용은 뮤텍스와 세마포어의 차이이다.

뮤텍스는 공유자원에 접근할 프로세스나 스레드를 하나로 제한하며 락을 가지면 락을 해제할 유일한 소유권을 주는 것이고,

세마포어는 접근 제한량 내에서 공유 자원에 접근할 프로세스나 스레드의 동시 접근을 허용하는 것이다. 락 개념이 아니기 때문에 소유권이 없다. 

여기서 세마포어의 종류가 이진 세마포어와 카운팅 세마포어로 나뉘는데, 이진 세마포어는 0과 1로 제어하여 마치 뮤텍스처럼 동작하지만 소유권 개념이 없다는 점에서 다르다는 것을 조원의 깔끔한 정리 덕에 새롭게 알게 되었다. !!

매번 느끼는 거지만 팀 활동 시간이 너무나 도움이 많이 되는 것 같다. 열심히 조사하며 고군분투할 시간이 절약 되는 기분이랄까 ..?


### 참고 자료 및 링크
카카오테크 부트캠프 트램폴린IDE 특강 및 조별 활동
