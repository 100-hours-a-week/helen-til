# 🧾TIL
## 날짜: 

- 학습 목표 1 : 블로킹, 논블로킹 개념 학습
- 학습 목표 2 : 동기, 비동기 개념  학습
- 학습 목표 3 : 블로킹,논블로킹,동기,비동기 조합 비교

## 새로 배운 내용
### 학습 키워드 한 줄 정리
|  | 정의 |
| --- | --- |
| 제어권 | 프로그램이 스스로 작업의 실행 순서와 방식을 결정할 수 있는 권한  |
| 동기 | 특정 함수가  실행되고 종료될 때까지 기다리는 처리 방식 |
| 비동기 | 특정 함수가  실행되고  반환까지 다른 작업을 수행할 수 있는 처리 방식 |
| 블로킹 | 현재 실행 중인 작업이 끝날 때까지  다음 작업을 할 수 없고 기다리는 상태 |
| 논블로킹 | 현재 실행 중인 작업이 끝나지 않아도 다음 작업을 계속 할 수 있는 상태  |

### 블로킹, 논블로킹

“현재 작업이 다른 작업의 실행을 차단하는가?”

블로킹의 경우 현재 진행 중인 작업이 끝나야만 다음 작업이 가능하고,

논블로킹의 경우  현재 진행 중인 작업이 끝나지 않아도 다음 작업을 하고 있을 수 있다.

차이는 **다른 작업에 영향을 주는가?** 이다.

### 동기와 비동기

“현재 작업과 다음 작업이 순서대로 실행되는가?”

- `동기` : 작업을  요청하면 끝날 때까지 기다리는 처리 방식이며, 순차적으로 실행된다.
- `비동기` :  요청한 작업을 기다리지  않고 다른 작업을 실행할 수 있는 처리 방식이다.

### 제어권 관점 블로킹, 논블로킹

- `블로킹` : 제어권을 완전히 전달 후 작업이 끝난 뒤 돌려 받음 → 다른 작업 할 수 없음
- `논블로킹` : 제어권을 전달 후 즉시 돌려 받아 다른  작업을 수행함.

⇒ 그러나 비동기 + 블로킹 조합에서 제어권을 바로 반환 받는데, 이 조합은 비동기 + 논블로킹으로 구현하다 잘못된 경우에 블로킹이 되어버린 경우라고 생각해도 좋겠다. 거의 사용되지 않는다.

### 파일 읽기 작업 예시

- 동기 & 블로킹
    
    ```jsx
    // 파일 읽기 작업 - 동기
    
    const fs = require('fs');
    
    console.log('파일 작업 시작');
    
    console.log('파일 작업 완료', fs.readFileSync('./2025-02-03.md'));
    
    console.log('다른 작업');
    
    // 출력
    C:\Program Files\nodejs\node.exe .\test.js
    파일 작업 시작
    파일 작업 완료 Buffer(6331) [35, 32, 240, 159, 167, 190, 84, 73, 76, 13, 10, 35, 35, 32, 235, 130, 160, 236, 167, 156, 58, 32, 50, 48, 50, 53, 45, 48, 50, 45, 48, 52, 13, 10, 35, 35, 35, 32, 236, 138, 164, 237, 129, 172, 235, 159, 188, 13, 10, 13, 10, 45, 32, 237, 149, 153, 236, 138, 181, 32, 235, 170, 169, 237, 145, 156, 32, 49, 32, 58, 32, 236, 139, 156, 236, 138, 164, 237, 133, 156, 32, 236, 149, 132, 237, 130, 164, 237, 133, 141, 236, 178, 152, 236, 157, 152, 32, 236, 160, 149, …]
    다른 작업
    ```
    
    ‘파일 작업  시작’ 출력 후 fs에 제어권을 넘겨 파일을 읽어오는 작업을 기다리며, 이후에 제어권을 돌려 받아 ‘다른  작업’을 출력한다.
    
- 비동기 &  논 블로킹
    
    ```jsx
    // 파일 읽기 작업 - 비동기
    
    const fs = require('fs');
    
    console.log('파일 작업 시작');
    
    fs.readFile('./2025-02-03.md', (err, data) => {
    	if(err) return err;
    	console.log('파일 작업 완료', data); 
    })
    
    console.log('다른 작업');
    
    // 출력
    C:\Program Files\nodejs\node.exe .\test.js
    파일 작업 시작
    다른 작업
    파일 작업 완료 Buffer(6331) [35, 32, 240, 159, 167, 190, 84, 73, 76, 13, 10, 35, 35, 32, 235, 130, 160, 236, 167, 156, 58, 32, 50, 48, 50, 53, 45, 48, 50, 45, 48, 52, 13, 10, 35, 35, 35, 32, 236, 138, 164, 237, 129, 172, 235, 159, 188, 13, 10, 13, 10, 45, 32, 237, 149, 153, 236, 138, 181, 32, 235, 170, 169, 237, 145, 156, 32, 49, 32, 58, 32, 236, 139, 156, 236, 138, 164, 237, 133, 156, 32, 236, 149, 132, 237, 130, 164, 237, 133, 141, 236, 178, 152, 236, 157, 152, 32, 236, 160, 149, …]
    
    ```
    
    ‘파일 작업 시작’ 출력 후 파일을 읽어오는 함수를 실행하며, fs로부터 제어권을 돌려 받는다. 
    
    ‘다른 작업’을 출력한다.  (논블로킹)
    
    이후 파일 읽기 작업이 끝나 callback 함수가 실행되면 ‘파일 작업 완료’를 출력한다.
    
     
    

### 다양한 조합

조합은 다양하게 가능하다.

동기 + 블로킹/ 동기 + 논블로킹 / 비동기 + 블로킹 / 비동기 + 논블로킹  조합 등이 있다.

**`동기 + 블로킹`** : 작업을 요청하고 제어권을 넘기고, 본인은 작업이 종료될 때까지 기다림. (제어권이 없으므로)

**`동기 + 논블로킹`** : 작업을 요청하고 제어권을 반환 받지만 작업이 끝날 때까지 계속 확인함 (polling)

**`비동기 + 블로킹`** :  작업을 요청하고 제어권을 반환 받아, 자신의 작업을 수행하다 의도치 않게 블로킹됨

**`비동기 + 논블로킹`** : 작업을 요청하고 제어권을 반환 받아, 자신의 작업을 수행함. 요청한 작업이 끝났다는 신호를 받으면 하던 작업을  끝내고 처리함

### 비동기 I/O와 논블로킹 I/O는 같은 개념일까?

결론부터 말하자면 **아니다.**

먼저 비동기 I/O는  I/O 작업이 끝나면 시그널 혹은 콜백의 형태로 회신한다.

하지만 논블로킹 I/O는  작업이 끝났는지 사용자가 직접 체크 하게 되며 완료 되지 않았을 경우는 에러를 회신한다. 

### 웹 서버 아키텍처에서 논블로킹 방식이 주는 성능적 이점

먼저, 블로킹 I/O 방식은 요청 후 기다려야 하기 때문에, 멀티스레드 환경인 서버 내에서 따로 스레드를 생성해 작업 한다. 해당 스레드는 대기 상태가 된다.

이에 따라 스레드를 생성하는데 부하가 있으며 컨텍스트 스위칭의 오버헤드도 있다.

하지만 논블로킹 I/O 방식은 같은 스레드 내에서 I/O 요청을 한 뒤 다른 작업을 할 수 있다. 따라서 컨텍스트 스위칭 오버헤드가 비교적 적어, 성능 상으로 더 이점이 있다.

### 오늘의 회고
동기, 비동기 방식은 자바스크립트를 사용하며 익혀두었던 개념이었고, 자신있게 설명할 수 있는 개념이다.
그러나 이번에 블로킹, 논블로킹 개념을 새로 이해하며 혼란에 빠져버렸다 .. 🥹
강의를 듣다가.. 그럼 블로킹  = 동기, 논블로킹 = 비동기 아니야??? 하는 구렁텅이에 빠졌고,
자습 시간에 열심히 교재를 훑어 보고, 검색도 해보며 스스로 다시 공부했다.
결국 이 개념들은 혼합해서 사용되는 비슷한 성격의 개념이지만 **관점**이 다르다.

내가 이해한 두 가지 개념의 관점은 아래와 같다.

블로킹/논블로킹은 다른 작업에 영향을 주는가?(블로킹),제어권을 가져와서 다른 작업을 실행할 수 있는가?(논블로킹)이고, 

동기/비동기는 순차적으로 작업이 끝날 때까지 기다려야 하는가?(동기), 흐름에 상관 없이 다른 작업을 하고, 완료 되었음을 알 수 있는가?(비동기)이다.

강의를 들으며 어떻게 이 차이를 이해하고 백지 상태에서 설명하지? 걱정이 되고 막막했지만 반복 학습으로 어느 정도 이해가 된 것 같아 매우 뿌듯하다🍀🍀

CS 지식일수록 반복 학습이 중요함을 잘 알고 있는데,  막상 실천하기가 쉽지 않은 것 같다. 화이팅 🏃🏻‍♀️🏃🏻‍♀️

### 참고 자료 및 링크
카카오테크 부트캠프 수업 및 교재
