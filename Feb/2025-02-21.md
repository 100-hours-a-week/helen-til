# 🧾TIL
## 날짜: 2025-02-21 (❁´◡`❁)

## 새로 배운 내용

# 프로그래밍 패러다임

: 프로그램을 구축하는데 사용되는 기본적인 접근 방식

## 절차지향형 프로그래밍 패러다임

```jsx
// 절차지향적으로 문제 해결
function calculateArea(width, height) {
    return width * height;
}

const width = 10;
const height = 5;
console.log("Area:", calculateArea(width, height));
```

- 명령어의 연속적인 실행 (x, y를 입력 받아 덧셈 처리)
- 데이터를 중심으로 함수를 절차적으로 수행

## 객체지향형 프로그래밍 패러다임

```jsx
// 객체를 사용해 문제 해결
class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }

    getArea() {
        return this.width * this.height;
    }
}

const rect = new Rectangle(10, 5);
console.log("Area:", rect.getArea());
```

- 데이터와 해당 데이터를 처리하는 메소드로 객체라는 단위를 만들어 상호작용하는 방식
- Java, C++, Python

## 함수지향형 프로그래밍 패러다임

```jsx
// 함수형 프로그래밍 스타일
const calculateArea = (width, height) => width * height;

const dimensions = { width: 10, height: 5 };
console.log("Area:", calculateArea(dimensions.width, dimensions.height));
```

- 함수를 **일급 시민(First-Class Citizen)** 으로 취급하고, 상태를 변경하지 않는 순수 함수(Pure Function)를 중심으로 작성하는 방식
    - **`일급 시민`** : **함수가 변수처럼 취급될 수 있다**는 뜻으로, 함수도 숫자, 문자열과 마찬가지로 자유롭게 전달하고 사용할 수 있는 요소로 취급
    - **`순수 함수`**: 동일한 입력→ 동일한 출력, 함수 외부의 상태를 변경하지 않으며 반환 값에만 집중하는 함수

## 비교하기

|  | **재사용성** | **유지보수성** |
| --- | --- | --- |
| 절차 지향 | 낮음 | 어려움 |
| 객체 지향 | 상속과 다형성을 통한 재사용 | 상대적으로 용이 |
| 함수형 | 함수 재사용 가능 | 매우 용이 (사이드 이펙트 없음) |
- **절차 지향**: 단순하고 빠른 코드가 필요한 경우 (예: 임베디드 시스템, 시스템 프로그래밍)
- **객체 지향**: 복잡한 데이터 구조를 관리해야 할 때 (예: 게임 개발, GUI 애플리케이션)
- **함수형**: 병렬 처리, 비동기 프로그래밍이 필요한 경우 (예: 데이터 처리, 실시간 애플리케이션)

또 다른 질문

절차 지향도 함수를 사용하고 함수형 프로그래밍도 함수를 사용하는데 왜 절차 지향 프로그래밍에서는 재사용성 및 유지보수가 어려울까?

**유지보수성**
절차 지향 프로그래밍에서는 데이터가 종종 전역 변수로 관리된다.
전역변수에 접근하는 함수가 여럿일 경우 어디서 변경되었는지 추적하기 어려워 유지보수가 어렵다.
또한 함수 내부의 변수에만 집중하는 함수형 프로그래밍과 달리, 절차 지향 프로그래밍은 함수와 데이터가 분리되어 있다.  따라서  여러 함수가 동일한 데이터를 공유해 의존도가 높을 경우 하나의 함수를 수정하면 다른 함수들도 영향을 받을 수 있어 수정해야 한다. 유지보수성이 좋지 않다.

**재사용성**

함수가 특정 전역 변수나 상태에 의존하면, 그 함수는 해당 상태가 존재하는 환경에서만 동작한다. 따라서 절차 지향에서는 전역 변수에 의존하는 경우가 많으므로 재사용이 어렵다.

|  |  |
| --- | --- |
| 자바스크립트 엔진 | 자바스크립트 코드를 실행하는 프로그램 또는 인터프리터  |
| 인터프리터 | 프로그래밍 언어를 기계가 이해할 수 있도록 해석하는 프로그램  |

## 인터프리터 언어

장점

- 수정하면 바로 확인할 수 있다
- 플랫폼 독립성

단점

- 한 줄씩 번역하기 때문에 실행 속도가 컴파일 언어보다 느리다
- 리소스 사용

⇒ 자바스크립트는 기본적으로 인터프리터 언어이다.

## 종류

- V8 엔진 - 가장 대표적이고, 많이 사용됨
- Rhino Engine
- SpiderMonkey Engine
- Chakra Engine
- Webkit Engine

## v8 엔진 내부 동작

v8 엔진은 느린 자바스크립트의 인터프리터 방식을 보완하기 위해 JIT 컴파일러를 도입했다.

JIT 컴파일러(TurboFan)는 실행 중 바이트 코드를 해석하면서 자주 실행되는 코드를 감지하고, 이를 기반으로 최적화된 머신 코드를 생성해 실행 속도를 향상시킨다.

토큰화 → parsing → AST 추상 구문트리 생성 → 바이트 코드 → 실행

- **`Parser` : AST 생성**
    - 렉시컬 분석 → 신택스 분석 → AST의 흐름으로 Abstract Syntax Tree를 만든다.
- **`Ignition`** : 바이트 코드 생성
    - 분석된 AST를 입력으로 사용해 Ignition 인터프리터가 바이트 코드를 생성 ⇒ 바이트 코드를 실행함으로써 진짜 소스코드가 실행됨
- **`TurboFan` : JIT 컴파일러, 자주 사용되는 부분 컴파일 해놓고 사용**
    - 자주 사용되는 코드(Hot Spot 과열지점)는 TurboFan으로 보내진다.
    - 이 코드를 Optimized Machine Code로 컴파일해놓고 사용한다. 최적화 되어 실행 속도가 빨라진다.

### 1. 생성과 컴파일 단계

- 코드 읽기 (토큰화)
    - 의미 있는 조각으로 나누는 과정
- 구문 분석 (AST 생성)
- 실행 컨텍스트 생성
    - 스택 구조에서 관리됨
    - 함수가 호출될 때마다 새로운 실행 컨텍스트가 스택에 추가됨
- 렉시컬 환경 및 **렉시컬 스코프** 결정
    - 렉시컬 환경: 접근 가능한 변수와 함수를 담고 있는 맵
    - **함수가 호출된 위치가 아닌 선언된 위치에 따라 스코프가 고정됨**
        
        ```jsx
        var num = 1;
        
        function a () {
        	var num = 2;
        	b(); 
        	
        }
        
        function b () {
        	console.log(num);
        }
        
        a(); // 1
        b(); // 1
        ```
        
        a 함수에서 b를 호출한 경우 num 값은 2가 아니라 1이다. 
        
        b 함수가 선언된 시점에서 상위 스코프가 결정되기 때문이다. (렉시컬 스코프)
        
- 호이스팅
    - 선언한 변수를 최상단으로 끌어올림

### 2. 실행

> 바이트 코드 생성
> 

> 변수 할당과 실행
> 

> 스코프 체인
> 

## JS 스택

- 실행 컨텍스트, 원시값을 저장하는 메모리 영역
- 함수 호출될 때 마다, 새로운 실행 컨텍스트가 스택에 push
- 함수 실행 완료되면 실행 컨텍스트가 pop
- 메모리 할당 빠르고 효율적이지만 저장 용량이 제한적이다 → 크기가 고정된 데이터(원시값, 실행컨텍스트) 저장하는데 적합하다
- 힙에 저장된 객체나 함수를 가리키는 참조값이 저장됨

## JS 힙

- 객체, 함수, 참조 타입 데이터를 저장하는 메모리 영역
- 데이터 자유롭게 할당하고 해제
- 렉시컬 환경도 힙에 저장
- 스택보다는 메모리 해제, 할당에 오래 걸린다.

### 오늘의 회고

오늘은 한 주 동안 배운 내용을 정리하고, 더 깊게 공부해보는 시간을 가졌다.

특히 나는 프로그래밍 패러다임을 맡아 책임지고 정리하였는데,

나름 절차 지향/객체 지향/함수형 프로그래밍 패러다임의 차이점에 대해 알고 있다고 생각했는데

함수형 프로그래밍이 함수 내 변수 값과 리턴 값에 집중하기 때문에 사이드 이펙트가 없으며, 따라서 유지보수성과 재사용성에 좋다고 답변한 내용에서,

 "객체 지향도 유지보수성과 재사용성이 좋지 않느냐? 어떻게 다른지?" 물어보는 모의 면접 질문에 잘 대답하지 못했다. 정리하면,

객체 지향 프로그래밍에서는 클래스를 기반으로 상속과 오버라이딩이 가능하며, 다형성을 통해 하나의 인터페이스로 객체에 따라 다르게 동작할 수 있다. 이를 통해 코드의 재사용성이 높아지고 유지보수가 용이해진다.

함수형의 경우 외부 상태에 의존하지 않기 때문에 함수를 재사용하고 유지보수 하기에 용이하다고 대답할 수 있을 것 같다.

절차 지향의 경우에만 유지보수성, 재사용성이 좋지 않고 나머지 객체 지향과 함수형의 경우는 유지보수성과 재사용성이 비교적 좋다고 할 수 있다.

정말 누군가에게 설명할 수 있을 정도로 공부하지 않으면 막상 입 밖으로 나오지 않는 것 같다.

조금 더 노력해야지 ,, 😬

### 참고 자료 및 링크
