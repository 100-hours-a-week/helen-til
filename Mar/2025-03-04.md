# 🧾TIL
## 날짜: 2025-03-04 😶‍🌫️


## 새로 배운 내용
## 학습 키워드 한 줄 정리
|  | 정의 | 비고 |
| --- | --- | --- |
| Database | 자료를 정보로 활용하기 위해 구조화 해놓은 데이터 모음 | 일관성: 데이터는 항상 정해진 제약 조건을 만족하며 트랜잭션이 실행된 후에도 데이터가 유효한 상태를 유지해야 한다. / 무결성: 데이터의 정확성과 신뢰성을 보장하며, 제약조건을 준수하여 변조되지 않도록 보호하는 것 |
| RDBMS | 관계형 데이터베이스를 관리해주는 프로그램 | RDB : 자료를 정보로 활용하기 위해 테이블 형태로 관계를 맺어 놓은 데이터 모음 |
| 정규화 | 이상현상을 방지하기 위해 테이블을 분리하는 것 | 이상현상으로는 삽입 이상, 삭제 이상, 갱신이상이 있다. 조인 비용이 증가한다. |
| 역정규화 | 분리된 테이블을 합치는 것 | 조인할 필요가 없어 비용이 줄어든다. 하지만 데이터가 중복될 확률이 높아진다. 이상현상이 발생할 수 있다. |
| JOIN | 원하는 데이터를 찾기 위해 관계를 기반으로 테이블을 합치는 연산 |  |
| View | 가상의 테이블을 만들어 선택적으로 조회하는 것 | 유지보수성과 재사용성이 높아진다. |
| Union | 쿼리 결과끼리 합하는 연산 | 중복 제거와 정렬을 수행하기 때문에 성능 문제가 발생할 수 있다. union all은 중복 제거를 하지 않는다. |
| ERD | 데이터베이스의 개체 간 관계를 시각적으로 표현하는 도표 |  |

## 정규화

이상현상(Anamoly)를 없애기 위해 테이블을 분리하는 과정

### `이상현상`

- 삽입 이상: 원치 않는 정보까지 같이 입력해야 하는 경우
- 삭제 이상:  데이터를 삭제할 때 관련된 정보까지 함께 삭제되는 경우
- 갱신 이상: 데이터 중복으로 인해 데이터를 갱신할 때 일관성이 없어지는 경우 (한 곳에서만 정보 갱신, 다른 곳 갱신하지 않으면 정보 사이 불일치 발생)

### `제 1 정규형`

- 하나의 컬럼에 하나의 값만 들어가야 함

### `제 2 정규형`

- 기본키가 아닌 나머지 칼럼들이 기본키 전체에 완전히 종속해야 함
- **부분 함수 종속성 제거**

### `제 3 정규형`

- **이행적 함수 종속성 제거**
- 속성들은 기본키에만 직접적으로 종속되어야만 함

## SQL

### `조인`

- **데이터타입 불일치 조인** ⇒ 암시적으로 형변환 발생
- **인덱스 없는 조인 컬럼** ⇒ Nested loop join 발생. 100만건 주문 데이터 있으면 100만번 만큼 비교, 성능 안 좋음
- **불필요한 outer join** ⇒ null 체크 로직이 추가되어 inner join보다 느리다.
- **서브쿼리**
    - 서브쿼리는 임시 테이블을 만들고 인덱스를 타지 않는다 (인덱스 미적용)
    

### `뷰`

뷰는 필요한 데이터를 선택적으로 보여주는 가상의 테이블을 생성해두는 개념으로,

데이터 조회를 빠르게 하고 재사용과 유지보수를 용이하게 하기 위해 사용한다. 

### `UNION`

두 SQL 쿼리 문의 결과를 합치는 연산자

```sql
SELECT p.name FROM product p
UNION
SELECT u.user_name FROM user u
```

JOIN은 테이블 사이의 관계를 기반으로 합친다면 UNION은 서로 관련이 없는 쿼리 결과를 합칠 때 사용된다. 

UNION은 쿼리 결과를 합치고 중복 레코드를 제거한다면 `UNION ALL`은 쿼리 결과를 합치기만 하고 **중복 레코드를 제거하지 않는다.**

📌 성능 문제

UNION 연산은 내부적으로 **중복 제거/ 정렬 작업을 하기 때문에 많은 비용이 발생**한다.

## ERD (Entity Relationship Diagram)

DB 구조를 시각적으로 문서화하기 위해, 개체와 관계를 한 눈에 알아볼 수 있도록 그린 도표

### `표기법`

- 까마귀 발 표기법 : 보편적으로 많이 사용 

- 바커 표기법

## 관계형 데이터 베이스의 핵심 특징

테이블 형태로 데이터를 저장하고, 각 테이블은 관계(키)를 통해 연결된다.

## 복합키 사용하는 상황

과목 개체에서 하나의 과목이 여러 분반을 갖는다면 과목코드와 분반 번호를 조합해서 복합키로 사용할 수 있다. 

## INNER JOIN과 LEFT JOIN의 차이

INNER JOIN은 조인 조건을 만족하는 행만 보여주는 것이고

LEFT JOIN은  (테이블 1) LEFT JOIN (테이블2) 일 때 테이블1의 모든 행을 유지하면서 조인 조건을 만족하는 경우 테이블2의 데이터도 함께 가져온다.

## Materialized View와 일반 뷰의 차이점

Materialized View는 물리적 테이블을 만들어 데이터를 조회하며, 최신의 데이터를 조회하려면 수동적으로 REFRESH 해주어야 한다. 

view는 가상의 테이블을 만들어 조회하며, 원본 테이블을 매번 조회하기 때문에 변경 사항이 자동으로 반영된다.

<aside>

**Materialized View를 사용하는 이유?**

조인 및 복잡한 집계 연산의 반복적인 실행을 줄이기 위해 사용된다.
이것은 view도 마찬가지인데, 대신 view는 원본 데이터를 매번 조회하므로 느릴 수 있기 때문에, 일정 주기로 갱신하는 데이터라면 수동 refresh를 하는 것이 성능 상 더 좋으므로, 이때 Materialized view를 사용한다.

</aside>

## VARCHAR와 CHAR

varchar는 가변 길이 문자를 저장할 때 사용,

char는 고정 길이 문자를 저장할 때 사용한다.

## DATETIME과 TIMESTAMP의 차이점

### **📌 DATETIME**

- 날짜·시간을 있는 그대로 저장, 범위가 넓고 변환 없이 그대로 사용 가능
- 8바이트 크기

### **📌 TIMESTAMP**

- **자동 업데이트 가능**, 범위가 제한적
    - 예를 들어 사용자가 블로그 글을 업로드 한 시간에서 편집 후 시간을 업데이트 해야 할 때 사용될 수 있다.
        
        ```sql
        CREATE TABLE posts (
            post_id INT PRIMARY KEY,
            title VARCHAR(255),
            content TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,   -- 생성 시간 (변경 없음)
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP -- 수정 시 자동 업데이트
        );
        
        ```
        
        ```sql
        UPDATE posts SET content = '새로운 내용' WHERE post_id = 1;
        ```
        
- 4바이트 크기
- Unix 타임스탬프로 변환해 저장

## GROUP BY와 HAVING의 차이점을 설명해주세요.

GROUP BY는 그룹을 나누는 조건 컬럼을 명시할 때 사용한다. 이때 where는 그룹핑 전에 필터링한다.

HAVING은 GROUP BY로 그룹화 된 데이터 중에서 조건을 걸 때 사용한다. HAVING은 그룹핑 후 필터링한다.

### 오늘의 회고
오늘은 데이터베이스에 대한 이론을 학습했다. 전공 수업에서 열심히 들었던 내용이라 이해하는데는 무리가 없었다.

하지만 공부해도 끝이 없다는 걸 잘 알기에 자만하지 않고 열심히 복습하는 중이다. 

특히 DATETIME, TIMESTAMP의 차이를 몰랐었는데, 예시를 찾아보고 정리하며 알게 되어 매우 뿌듯하다. 🐻‍❄️

이제는 "왜 쓰는지(필요한지)"를 중점적으로 공부하다보니, 이론 공부임에도 이런 고민이 먼저 자리잡게 되어 매우 좋다고 생각한다.

이전에는 가져다 쓰기 바빴다면 이젠 조금 더 큰 그림을 보기 위해 노력하고 있는 것 같다.

진짜로 설계할 줄 아는 개발자가 되어가고 있는 느낌이다. 많이 성장하고 있다는 게 느껴져서 행복한 요즘이다.
